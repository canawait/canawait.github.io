{"meta":{"title":"Mars.Wang","subtitle":"work hard, play hard","description":"种一棵树最好的时间是十年前，其次是现在","author":"Mars","url":"http://canawait.github.io"},"pages":[{"title":"文章分类","date":"2017-01-24T11:24:59.000Z","updated":"2017-01-24T11:25:37.000Z","comments":false,"path":"categories/index.html","permalink":"http://canawait.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"标签","date":"2017-01-24T11:23:01.000Z","updated":"2017-01-24T11:24:35.000Z","comments":false,"path":"tags/index.html","permalink":"http://canawait.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"TCP编程基础","slug":"network-base","date":"2017-01-23T10:35:26.000Z","updated":"2017-01-24T11:50:18.000Z","comments":true,"path":"2017/01/23/network-base/","link":"","permalink":"http://canawait.github.io/2017/01/23/network-base/","excerpt":"","text":"本文主要整理了在TCP编程过程中，常用的一些函数，以及常会遇到的一些异常情况，以及如何对这些情况进行处理 建立连接int connect(int sockfd, const struct sockaddr* svraddr, socklen_t addrlen) 成功返回 0 ， 出错返回 -1（注意：出错不一定代表建立连接失败，以下会分析） 从tcp协议的角度来看，connect将触发tcp三次握手，向对端发送SYN包，在 非阻塞 模式下，connect会在收到对端的SYN+ACK包后返回 阻塞模式返回条件 阻塞在connect调用，直至成功建立连接或发生错误 可以通过返回值判定建立连接是否成功，0 表示成功， -1 表示失败 返回值 返回 0表示连接建立成功 返回 -1表示建立连接失败，几种常见的错误码分析： ETIMEOUT客户端没有收到SYN分节的确认，建立连接超时（不需要程序处理） ECONNREFUSED客户端收到对SYN分节的响应是RST，表示服务器主机在指定的端口上没有进程在等待与之连接（不需要程序处理） EHOSTUNREACH/ENETUNREACH表示连接的服务器地址 目的地不可达（不需要程序处理） EINTERconnect被内核终端，且内核没有自动重启该函数（不需要程序处理） 非阻塞模式返回条件 connect成功建立连接，并返回0 （成功建立连接） connect立即返回-1，设置错误码EINPROGRESS（正在建立连接） connect立即返回-1，设置EINPROGRESS以外错误码（建立连接失败） I/O复用函数超时返回 （建立连接失败） socket变为 可读或可写，I/O复用函数正常返回：(1) getsockopt(SO_ERROR)为 0 （成功建立连接）(2) getsockopt(SO_ERROR)非 0 （建立连接失败） 不能简单通过connect返回值来判断建立连接是否成功。返回 0 表示建立连接成功。返回 -1 且错误码不为EINPROGRESS表示连接建立失败。I/O复用（select，poll，epoll）返回socket可读或可写，并且getsockopt(SO_ERROR)为0表示建立连接成功，如果不为0表示建立连接失败 返回值 返回 0建立连接成功。在非阻塞模式下，一般很少会返回0，因为建立至少要经历一个RTT的时间，但如果是在同一台主机上建立连接，有可能立即建立成功，所以在编程的时候要处理这种情况 返回 -1在非阻塞模式下，返回-1并不完全都表示建立连接失败，几种常见错误码分析： EINPROGRESS表示建立连接已经启动（注意：不是EAGAIN/EWOULDBLOCK）但还未完成，不表示连接建立失败（需要程序处理：忽略该错误） 其他其他错误码都表示建立连接失败，常见的几种与阻塞模式是一致的，参考上面 accept连接int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *len) 成功返回非负已连接描述符，出错返回 -1accept成功返回时，会从已完成队列队头返回下一个已完成的连接。注意：tcp三次握手第三次结束后，tcp仅仅是把连接从未完成连接队列移到已完成连接队列，所以不能说三次握手结束，accept就一定会返回。所以第三次握手结束是accpet返回的必要非充分条件，反过来为充分非必要条件 阻塞模式返回条件 阻塞在accept调用，直至成功accept到连接或发生错误 返回值 返回非负数 accept成功 返回 -1 accept失败非阻塞模式返回条件 I/O复用函数超时返回 socket变为 可读，I/O复用函数正常返回，accept立即返回(1) accept返回非负已连接描述符 （成功accept连接）(2) accept返回-1，并且errno为EWOULDBLOCK、ECONNABORTED、EPROTO、EINTER之一 （accept连接出现可忽略错误）(3) accept返回-1，并且errno为非EWOULDBLOCK、ECONNABORTED、EPROTO、EINTER之中任一个（accept连接出现严重错误） I/O复用返回描述符可读，而且errno为0表示accept连接成功，此时返回非负已连接描述符。返回-1且错误码 不为 EWOULDBLOCK、ECONNABORTED、EPROTO、EINTER则表示accept连接出错 返回值 返回非负数 accept成功 返回 -1 非阻塞模式下，返回-1不一定表示accept连接失败。几种常见错误码分析： EWOULDBLOCK表示tcp已经将连接移到已完成连接队列中，但在accept之前客户端提前终止了连接（客户端直接发送RST包）。这不表示accept建立失败（Berkeley实现方式，需要程序处理：忽略该错误） ECONNABORTED表示tcp已经将连接移到已完成连接队列中，但在accept之前客户端提前终止了连接。这不表示accept建立失败（POSIX实现方式，需要程序处理：忽略该错误） EPROTO表示tcp已经将连接移到已完成连接队列中，但在accept之前客户端提前终止了连接。这不表示accept建立失败（SVR4实现方式，需要程序处理：忽略该错误） EINTERI/O多路复用执行过程中，有信号被捕获（需要程序处理：忽略该错误） 接收数据size_t read(int fd, void *buf, size_t len) 成功读取返回非负整数，返回 -1且errno不为EAGAIN为读取失败 阻塞模式返回条件 阻塞在read调用直至 有数据可读取 （成功读取） 发生错误，且errno为EINTER （read出现可忽视错误） 发生错误，且errno不为EINTER （read出现严重错误） 返回值 返回非负数 读取成功。如果为0表示读到EOF，没有更多数据可读。如果为正整数，表示成功读回的字节数 返回 -1 返回-1不一定表示读取失败。常见错误码分析： EINTER在读取过程中，进程捕获到信号（需要程序处理：忽略该错误） 其他读取失败，结束读取 非阻塞模式返回条件 I/O复用函数超时返回 socket变为 可读，I/O复用函数正常返回，read立即返回(1) read返回非负整数 （成功读取数据）(2) read返回-1，且errno为EINTER、EAGAIN/EWOULDBLOCK （read出现可忽略错误）(3) read返回-1，且errno非EINTER、EAGAIN/EWOULDBLOCK其中之一 （read出现严重错误） 返回值 返回非负数 读取成功。如果为0表示读到EOF，没有更多数据可读。如果为正整数，表示成功读回的字节数 返回 -1 返回-1不一定表示读取失败。常见错误码分析： EINTER在读取过程中，进程捕获到信号（需要程序处理：忽略该错误） EAGAIN/EWOULDBLOCK当前暂时没有数据可读（需要程序处理：忽略该错误） ECONNRESET对端reset了连接 （需要程序处理：关闭套接字） 其他读取失败，结束读取 发送数据size_t write(int fd, const void *buf, size_t len) 成功写入返回非负整数，返回 -1 且errno不为EAGAIN为读取失败 阻塞模式返回条件 内核缓冲区满，阻塞在write调用直至(1) 缓冲区非满，返回写入字节数 （成功写入）(2) 发生错误，且errno为EINTER （write出现可忽视错误）(3) 发生错误，且errno不为EINTER （write出现严重错误） 内核缓冲区非满，直接返回写入字节数 返回值 返回非负数 写入成功。write操作极少可能会返回 0。如果为正整数，表示成功写入的字节数 返回 -1 返回-1不一定表示读取失败。常见错误码分析： EINTER在写入过程中，进程捕获到信号（需要程序处理：忽略该错误） 其他读取失败，结束读取 非阻塞模式通常write操作一开始都是不需要加入到I/O多路复用中的，因为如果没有数据发送过，内核缓冲区一般都是可写的，write一般不会阻塞。所以一般是需要满足一定条件后才将write操作加入I/O多路复用，通常这个条件会因为不同的需求而不同 返回条件 I/O复用函数超时返回 socket变为 可写，I/O复用函数正常返回，write立即返回(1) read返回非负整数 （成功读取数据）(2) read返回-1，且errno为EINTER、EAGAIN/EWOULDBLOCK （read出现可忽略错误）(3) read返回-1，且errno非EINTER、EAGAIN/EWOULDBLOCK其中之一 （read出现严重错误） 返回值 返回非负数 写入成功。write操作极少可能会返回 0。如果为正整数，表示成功写入的字节数 返回 -1 返回-1不一定表示读取失败。常见错误码分析： EINTER在写入过程中，进程捕获到信号（需要程序处理：忽略该错误） EAGAIN/EWOULDBLOCK当前内核缓冲区满，暂时不可写（需要程序处理：忽略该错误） ECONNRESET对端reset了连接 （需要程序处理：关闭套接字） 其他写入失败，结束写入 关闭连接int close(int fd)int shutdown(int fd, int howto) 注意 在理解close和shutdown的时候，一定要分两个层面来看，一个是用户层，一个是内核实现的TCP协议层 close不但能关闭套接字，还能关闭一切文件。close结合SO_LINGER选项，可以有三种关闭方式shutdown只能用于关闭套接字。shutdown函数同样结合传入的howto参数，也可以有三种不同的关闭方式 为什么已经有了close函数，仍然需要shutdown函数呢？主要基于以下两点: 在多进程共享同一个socket的情况下，close仅仅是对socket的引用数减 1，直至减为 0 时才真正的关闭socket，shutdown则不然，一旦执行无论有多少个进程共享该socket都会直接关闭socket，并触发TCP发送FIN包 close一旦执行调用的它的进程不能对socket进行读和写（注意：只是进程将socket标志为不可读写，而不是TCP在两个方向上的连接都关闭了），shutdown却能允许只关闭连接的一半 close的三种关闭方式 struct linger中的l_onoff为 0close会立即返回，正常关闭返回 0 ， 关闭错误返回 -1。close返回并不会等待TCP发FIN，更不会等待对端对FIN包的ACk 该情况是close的默认情况。进程将socket标志为不可读和写，TCP清楚接收缓冲区中的数据，并尝试发送已在发送缓冲区中的数据到对方，发送完毕后发FIN包。注意是“尝试”发送，说明此条件下并不保证发送缓冲区中的数据一定被TCP对端接收，更不用说保证对端的进程能够收到 struct linger中的l_onoff为1，l_linger为0close会立即返回，正常关闭返回 0 ， 关闭错误返回 -1。 进程将socket标志为不可读和写。TCP立刻丢弃接收及发送缓冲区中的数据，并向对端发送RST包，而不是一个TCP正常4个结束分组。这种情况可以避免产生TCP的TIME_WAIT状态，但同时这也会带来一个弊端：来自刚被终止的连接上的旧的重复分组被不正确地送到了旧连接的新化身上 struct linger中的l_onoff为 1， l_linger不为 0（延滞时间） 阻塞模式close不会立即返回，如果发送缓冲区中仍有数据待发送进程会进入睡眠 进程将socket标志为不可读和写。TCP清理读缓冲区中的数据。如果发送缓冲区中仍有数据（1）TCP将所有数据发送完并收到对端确认（只是保证了TCP对端已经正常接收到数据，进程是否接收到无法保证）。close返回 0（2）设定的延滞时间到，发送缓存区中剩余数据被丢弃。close返回 -1，并且errno为EAGAIN/EWOULDBLOCK，（向对端发送RST？） 非阻塞模式close立即返回 -1，并且errno为EAGAIN/EWOULDBLOCK 进程将socket标志为不可读和写。TCP清理读缓冲区中的数据。如果发送缓冲区中仍有数据（1）TCP将所有数据发送完并收到对端确认（只是保证了TCP对端已经正常接收到数据，进程是否接收到无法保证）（2）设定的延滞时间到，发送缓存区中剩余数据被丢弃。（向对端发送RST？） shutdown的三种关闭方式 howto为SHUT_RD关闭连接读这一半 套接字变为不可读，但仍可写。接收缓冲区中的剩余数据都将会被丢弃。如果对端继续有数据发送过来，TCP会回送确认，并只是简单将数据丢弃 howto为SHUT_WR关闭连接写这一半 将当前剩余在发送缓冲区中的数据发送到对端，完之后向对端发送FIN包，之后进程不能再进程写操作，但仍可读进程如果在调用shutdown之后，仍坚持调用read，可以一直到收到对端的FIN（read返回0）才返回，这样就可以确认最后发送出去的数据已经被对端的进程接收 howto为SHUT_RDWR关闭连接的读半部和写半部，是前两者的的结合","raw":null,"content":null,"categories":[{"name":"Linux开发技术","slug":"Linux开发技术","permalink":"http://canawait.github.io/categories/Linux开发技术/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://canawait.github.io/tags/网络编程/"}]}]}